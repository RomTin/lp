// Yaccプログラムの例１：簡単な電卓のためのYaccプログラム

/* このファイルが Yacc で処理されると、構文解析関数 yyparse() と */
/* 関数定義部に含まれる関数定義を含んだファイル y.tab.c が	 */
/* 生成される．							 */


// 宣言部: C宣言部とYacc宣言部を含む．

%{
// C宣言部: 翻訳規則で使われる定数、型名などの宣言や
// それらを含むヘッダファイルのインクルードを行う．
#include <stdio.h>

/* Yaccを使うときは，以下の２つの関数は必ずどこか（別ファイル中でも
   可）で定義しなければならない．これらの関数は，Yaccが生成する
   構文解析関数yyparse()から呼び出されるので，calc1.y 中では
   これらの関数を呼び出す処理は書かなくてよい．
*/
extern int yylex(void);		// 字句解析のための関数(別ファイルで定義)
int yyerror(const char *msg);	// エラー処理のための関数
%}

// Yacc宣言部: 翻訳規則で使われるトークンや
// 非終端記号についての宣言をここに記述する．

%start calc	// 文法の開始記号が calc であることを示す(省略可能)．
                // %start がないときは，翻訳規則部の先頭にある
                // 翻訳規則の左辺の非終端記号が開始記号になる．

// トークンの宣言は必須(ただし'='のように，文字コードそのものが
// トークンであり，かつ，属性をもたないものは宣言しない)

%token NUM	// トークン NUM の宣言

// 非終端記号の宣言は属性名を指定する必要があるときだけ行う．

// ここでは，トークンと非終端記号の属性名を特に指定していないので，
// すべてのトークンと非終端記号の属性の型は，デフォルトのint型に
// になる（yylval の型が int ということ）．


%% // 宣言部と翻訳規則部の区切りは %%


/* 翻訳規則部: Yaccは，以下に書かれた翻訳規則をもとにして，*/
/* 	       LR構文解析表を生成する			   */


// calc の翻訳規則
calc : expr ';'		{ printf("%d\n",$1); }
     ;

// expr の翻訳規則
expr : expr '+' term	{ $$ = $1 + $3; }
     | term		{ $$ = $1; }
     ;

// term の翻訳規則
term : term '*' factor	{ $$ = $1 * $3; }
     | factor		{ $$ = $1; }
     ;

// factor の翻訳規則
factor: NUM		{ $$ = $1; }
      | '(' expr ')'	{ $$ = $2; }
      ;


%%  // 翻訳規則部と関数定義部との区切りも %%


/* 関数定義部: Yacc が生成するファイル y.tab.c に含めたい */
/*	       関数定義をここに書く．			  */


/* エラー処理関数 yyerror() の定義				*/
/* Yacc が生成する構文解析関数 yyparse() は，構文解析エラーが	*/
/* 発生したとき、yyerror() を呼び出す．引数は、エラーメッセージ */
/* ここでは、単にメッセージを出力するだけにしているが、yyerror()*/
/* を適当に定義することで、さまざまなエラー処理が可能になる．	*/

int yyerror(const char *msg)
{
  fprintf(stderr,"%s\n",msg);
  return 0;
}

/* main() の定義					*/
/* Yaccが生成する構文解析関数 yyparse() を呼び出す．	*/

main()
{
/* #if YYDEBUG から #endif まではデバッグプリント．
   bison を実行するとき，-t オプションを指定すると，
   生成される構文解析系のC ファイル y.tab.c の先頭で，
   定数 YYDEBUG の値が 1 になる．YYDEBUG の値が 1 のときに
   y.tab.c をコンパイルすると，構文解析系のデバッグが有効になる
*/
#if YYDEBUG		// Yaccプログラムのデバッグでは必ずYYDEBUGを使う
  extern int yydebug;	// Yaccプログラムのデバッグのための大域変数

  yydebug = 1;	// yydebug の値が 1 のとき，デバッグ情報の出力を行う．
                // -t オプションを指定して bison を実行しても，
                // yyparse() 実行前に yydebug の値を 1 にしなければ
	        // デバッグ情報の出力は行われない．
#endif

  yyparse();
}

